const BST_SEARCH = "Given the BST as shown in the picture, click the sequence of vertices that are visited by Search(|value|).";
const BST_TRAVERSAL = "Given the BST as shown in the picture, click the sequence of vertices that are visited by |subtype|(root).";
const BST_SUCCESSOR = "Given the BST as shown in the picture, click the sequence of vertices that are visited by Successor(|value|).";
const BST_PREDECESSOR = "Given the BST as shown in the picture, click the sequence of vertices that are visited by Predecessor(|value|).";
const BST_MIN = "What is the value of the minimum element in this BST?";
const BST_MAX = "What is the value of the maximum element in this BST?";
const BST_K_SMALLEST_VALUE = "What is the value of the element with rank |value| in this BST?";
const BST_DELETION = "Given the normal BST (not AVL) as shown in the picture, delete at most |maxAmt| vertex/vertices such that the height of the BST decreases by 1.";
const BST_SWAP = "Is the graph in the picture a valid BST?";
const BST_IS_AVL = "Is the graph in the picture a valid AVL?";
const BST_HEIGHT = "What is the height of this BST?";
const BST_ROOT = "Click the root of this BST.";
const BST_LEAVES = "Click all the leaf vertices (in any order) of this BST.";
const BST_INTERNAL = "Click all the internal vertices (in any order) of this BST.";
const BST_AVL_ROTATION_INSERT = "Given the AVL as shown in the picture, insert at least |limitBtm| vertex/vertices and at most |limitTop| vertex/vertices such that |rotationAmt| rotation(s) occur(s).";
const BST_AVL_ROTATION_DELETE = "Given the AVL as shown in the picture, delete at least |limitBtm| vertex/vertices and at most |limitTop| vertex/vertices such that |rotationAmt| rotation(s) occur(s).";
const BST_AVL_HEIGHT = "";

const HEAP_INSERTION = "An integer |value| is going to be inserted into the binary |subtype| heap as shown in the picture, click the sequence of vertices that will swap their content with vertex |value| during this insertion.";
const HEAP_EXTRACT = "We are performing extract operation to the binary |subtype| heap as shown in the picture, click the sequence of vertices that will swap their content with the leaf vertex that replaces the root node.";
const HEAP_HEAP_SORT = "We perform |amt| extract operations to the binary |subtype| heap as shown in the picture, click all vertices (in any order) that will remain in the binary |subtype| heap after all these operations are executed.";
const HEAP_HEAPIFY = "We perform O(n) Build Heap to the binary |subtype| heap as shown in the picture, click all vertices (in any order) that violates the property of a |subtype| heap and will be shifted down.";
const HEAP_ROOT = "Click the root of this heap.";
const HEAP_LEAVES = "Click all the leaf vertices (in any order) of this heap.";
const HEAP_INTERNAL = "Click all the internal vertices (in any order) of this heap.";
const HEAP_GREATER_LESS = "Click all vertices (in any order) that are |greaterless| than |value| in this |subtype| heap.";
const HEAP_RELATIONS = "Click the |relation| of |value|.";
const HEAP_IS_HEAP = "Is this a valid |subtype| heap?";

const BITMASK_OPERATIONS = "What is the integer result of |value| |subtype| (1 << |shiftAmt|)?";
const BITMASK_CONVERT = "What is the |toBase| representation of |fromBase| value |value|?";
const BITMASK_NUMBER_ON = "How many bit(s) in the binary representation of |value| is/are 1?";
const BITMASK_LSONE = "What is the index of the least significant bit (first bit counted from the right, 0-based indexing) that is 1 in the binary representation of |value|?";

const UFDS_FIND_SET_COMPRESSION = "Given the UFDS as shown in the picture, click all vertices (in any order) such that when findSet(v) is performed on vertex v, the UFDS structure changes! The path compression and union by rank heuristics are used.";
const UFDS_FIND_SET_SEQUENCE = "Given the UFDS as shown in the picture, click the sequence of vertices that are visited by findSet(|value|).";
const UFDS_IS_SAME_SET = "Given the UFDS as shown in the picture, click all vertices (in any order) that belongs to the same set as |value|.";

const MST_PRIM_SEQUENCE = "Given the undirected weighted graph as shown in the picture, click the first |amt| edges in the sequence of edges that are added to the Minimum Spanning Tree by Prim\'s algorithm starting at vertex |value|.";
const MST_KRUSKAL_SEQUENCE = "Given the undirected weighted graph as shown in the picture, click the first |amt| edges in the sequence of edges that are added to the Minimum Spanning Tree by Kruskal\'s algorithm.";
const MST_MINIMAX_EDGE = "Click the edge that has the |opp|imum edge weight along the |subtype|i|opp| path from vertex |vertexA| to vertex |vertexB|. The |subtype|i|opp| path between two vertices is defined as the path that |subtype|imizes the |opp|imum edge weight between the two vertices.";

const SSSP_GREATER_LESS = "Click all vertices (in any order) in this directed weighted graph that are reachable from source vertex |source| and have shortest path values |greaterless| than |value| from the source. Note that all edge weights are printed closer to the arrowheads of the respective arrows.";
const SSSP_PATH = "Click the sequence of vertices that constitutes the shortest path from source vertex |source| to vertex |value|. If vertex |value| is unreachable from the source, select 'No Answer'. Note that all edge weights are printed closer to the arrowheads of the respective arrows.";
const SSSP_PATH_WEIGHT = "What is the weight of the shortest path from source vertex |source| to vertex |value|? If |value| is unreachable from the source, select 'No Answer'. Note that all edge weights are printed closer to the arrowheads of the respective arrows.";

const GRAPH_DS_DS_SIZE = "How many cells are there in the Adjacency Matrix for this graph?";
const GRAPH_DS_NEIGHBOURS = "Click on all neighbours of vertex |value| (in any order). If vertex |value| has no neighbours, select 'No answer'.";
const GRAPH_DS_NONZERO = "How many cells in the Adjacency Matrix of this graph are not empty/zero?";

const GRAPH_TRAVERSAL_TRAVERSAL = "Click the sequence of vertices that are visited by |subtype| from source vertex |value|. The neighbours of a vertex are listed in ascending vertex number.";
const GRAPH_TRAVERSAL_DISCONNECT = "Click all vertices (in any order) that will cause the graph to be disconnected if deleted. Note that the vertex deletion is independent.";